var documenterSearchIndex = {"docs":
[{"location":"fcup/#FCUP","page":"FCUP","title":"FCUP","text":"Pages = [\"fcup.md\"]\nDepth = 3\n\nThis is a more advanced tutorial because we want to show how to apply a mask.","category":"section"},{"location":"fcup/#Define-the-TMC","page":"FCUP","title":"Define the TMC","text":"import Tractography as TG\n\nmodel = TG.TMC(Œît = 0.125f0,\n            foddata = TG.FODData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            cone = TG.Cone(45),\n            proba_min = 0.015f0,\n            )\n\nJust for fun, we plot the FODs of the model.\n\nusing CairoMakie\n\nf, sc = TG.plot_fod(model; n_sphere = 1500, radius = 0.3, st = 2);\ncam3d = Makie.cameracontrols(sc)\ncam3d.eyeposition[] = Vec3f(85, 95, -28)\ncam3d.lookat[] = Vec3f(84, 95, 59)\nrotate_cam!(sc.scene, 0, 0, -pi/2)\nf","category":"section"},{"location":"fcup/#Define-the-seeds","page":"FCUP","title":"Define the seeds","text":"We next apply a mask on the boundary of which the streamlines stop.\n\nusing NIfTI\nmask = NIfTI.niread((@__DIR__) * \"/../../examples/wm-FC.nii.gz\");\nTG._apply_mask!(model, mask);\n\nWe compute Nmc streamlines, hence we need Nmc seeds\n\nNmc = 100_000\nseeds = TG.from_fod(model, Nmc; maxfod_start = true)","category":"section"},{"location":"fcup/#Compute-the-streamlines","page":"FCUP","title":"Compute the streamlines","text":"streamlines, tract_length = TG.sample(model, TG.Deterministic(), seeds; nt = 1000);\nprintln(\"Dimension of computed streamlines = \", size(streamlines))","category":"section"},{"location":"fcup/#plot-the-streamlines","page":"FCUP","title":"plot the streamlines","text":"f, scene = @time TG.plot_fod(model; n_sphere = 500, radius = 0.3, st = 1);\nind_st = findall(tract_length .> 60)\nTG.plot_streamlines!(scene, streamlines[:, :, ind_st[1:10:end]])\nf\n\nWe can also add the seeds\n\nscatter!(scene, seeds[1:3, ind_st[1:10:end]], color = :white)\nf","category":"section"},{"location":"fcup/#Compute-the-connections","page":"FCUP","title":"Compute the connections","text":"When computing structural connectivity, we don't need to record the entire streamline but only its extremities.\n\nstreamlines, tract_length = TG.sample(model, TG.Connectivity(TG.Deterministic()), seeds; nt = 1000);\nprintln(\"Dimension of computed streamlines = \", size(streamlines))","category":"section"},{"location":"connectivity/#Structural-connectivity-estimate","page":"Structural connectivity estimate","title":"Structural connectivity estimate","text":"Pages = [\"connectivity.md\"]\nDepth = 3\n\nThe algorithm Tractography.Connectivity allows to estimate structural connectivity. In short, \n\nalg = Tratography.Connectivity(Tratography.Deterministic())\nstreamlines, tract_length = TG.sample(model, alg, seeds);\n\nreturns the first/last point on the streamline. You are then required to map both points with an atlas.","category":"section"},{"location":"library/#Library","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"section"},{"location":"library/#Seeds","page":"Library","title":"Seeds","text":"","category":"section"},{"location":"library/#sheval","page":"Library","title":"Spherical harmonics evaluation strategy","text":"","category":"section"},{"location":"library/#Models","page":"Library","title":"Models","text":"","category":"section"},{"location":"library/#Algorithms","page":"Library","title":"Algorithms","text":"","category":"section"},{"location":"library/#Sampling","page":"Library","title":"Sampling","text":"","category":"section"},{"location":"library/#Plotting","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"library/#Misc","page":"Library","title":"Misc","text":"","category":"section"},{"location":"library/#Tractography.from_fod","page":"Library","title":"Tractography.from_fod","text":"from_fod(\n    model::TMC{ùíØ},\n    n_seeds::Int64;\n    n_sphere,\n    maxfod_start\n) -> Any\n\n\nGenerate seeds from orientation distribution functions.\n\nKeyword arguments\n\nmaxfod_start = false The seeds are generated in voxels with non-zero average FOD with the orientations importance sampled.\nmaxfod_start = true The seeds are generated in voxels with non-zero average FOD with the orientations corresponding to the maximum probability.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.from_mask","page":"Library","title":"Tractography.from_mask","text":"from_mask(\n    model::TMC{ùíØ},\n    mask::AbstractArray{Bool, 3},\n    n_seeds::Int64\n) -> Any\n\n\nGenerate seeds from a 3D mask. The seeds are generated randomly inside voxels with non-zero values in the mask. The orientations are random.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.PlottingSH","page":"Library","title":"Tractography.PlottingSH","text":"struct PlottingSH <: Tractography.AbstractSPHEvaluation\n\nSet up for plotting ODF.\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.PreComputeAllFOD","page":"Library","title":"Tractography.PreComputeAllFOD","text":"struct PreComputeAllFOD <: Tractography.AbstractSPHEvaluation\n\nSpherical harmonics evaluation based on Fibonacci sampling. All ODF are pre-computed once and saved in a cache. Their positivity is enforced with a max(0,‚ãÖ) or a mollifier. \n\ndanger: Danger\nRequires a relatively large memory!\n\nDetails\n\nIf you have na angles for sampling the unit sphere and the data is of size (nx, ny, nz, nsph), it yields a matrix of dimensions (nx, ny, nz, na).\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.FODData","page":"Library","title":"Tractography.FODData","text":"struct FODData{ùíØ, ùíØd, ùíØs, ùíØt}\n\nStructure to hold FOD data.\n\nFields\n\nfilename::String: filename from which the (fod) data is read.\ndata::Any: field which contains the FOD data.\nlmax::Int64: max l coordinate in of spherical harmonics.\ntransform::Tractography.Transform: transform associated with data, see Transform.\nnormalized::Bool: Are the data normalized? In this case fod[i,j,l,1] ‚àà {0,1}.\n\nMethods\n\nget_lmax(::FODData) returns the max l coordinate in of spherical harmonics.\nsize(::FODData) returns the size of the data.\nget_range(::FODData) returns the range of the data in the real world coordinates.\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.TMC","page":"Library","title":"Tractography.TMC","text":"struct TMC{ùíØ, ùíØalg<:Tractography.AbstractSPHEvaluation, ùíØd, ùíØC, ùíØmol}\n\nTractography Markov Chain (TMC).\n\nFields (with default values):\n\nŒît::Any: Step size of the TMC. Default: 0.1\nevaluation_algo::Tractography.AbstractSPHEvaluation: Spherical harmonics evaluation algorithm. Can be FibonacciSH(), PreComputeAllFOD(). Default: PreComputeAllFOD()\nfoddata::Any: ODF data from nifti file. Must be the list of ODF in the base of spherical harmonics. Hence, it should be an (abstract) 4d array. Default: nothing\ncone::Any: Cone function to restrict angle diffusion. You can use a Cone or a custom function (d1, d2) -> return_a_boolean. Default: Cone(90.0f0)\nproba_min::Any: Probability below which we stop tracking. Default: 0.0\nmollifier::Any: Mollifier, used to make the fodf non negative. During odf evaluation, we effectively use mollifier(fodf[angle,i,j,k]). Default: max_mollifier\n\nMethods\n\n_apply_mask!(model, mask) apply a mask to the raw SH tensor. See its doc string.\n_getdata(model) return the fodf data associated with the TMC.\nsize(model) return nx, ny, nz, nt.\neltype(model) return the scalar type of the data (default Float64).\nget_lmax(model) return the max l coordinate in of spherical harmonics.\n\nConstructors (use the fields!)\n\nTMC()\nTMC(Œît = 0.1f0) for a Float32 TMC\nTMC(Œît = 0.1, proba_min = 0.) for a Float64 TMC. You need to specify both fields Œît and proba_min\nTMC(odfdata = rand(10,10,10,45)) for custom ODF\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.Deterministic","page":"Library","title":"Tractography.Deterministic","text":"struct Deterministic <: Tractography.DeterministicSampler\n\nTractography sampling performed with the argmax function. Can be used with FibonacciSH and PreComputeAllFOD.\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.Probabilistic","page":"Library","title":"Tractography.Probabilistic","text":"struct Probabilistic <: Tractography.AbstractNotPureRejectionSampler\n\nTractography sampling performed with the cumulative sum distribution. Can be used with FibonacciSH and PreComputeAllFOD.\n\nConstructor\n\nProbabilistic()\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.Diffusion","page":"Library","title":"Tractography.Diffusion","text":"struct Diffusion{T, Tmol, Tdmol} <: Tractography.AbstractSDESampler{T}\n\nTractography sampling performed with diffusive model. Basically, the streamlines (X‚Çú)‚Çú are solution of the SDE\n\ndX‚Çú = Œ≥‚ãÖdrift(X‚Çú)‚ãÖdt + ‚àö(2Œ≥ ‚ãÖ Œ≥_noise) ‚ãÖ dnoise‚Çú\n\nwhere\n\ndrift(X‚Çú) = (X‚Çú¬≤, ‚àálog f(X‚Çú))\n\nArguments (with default values):\n\nŒ≥::Any: Œ≥ parameter of the diffusion process. It is related to the curvature of the streamline. Default: 1.0\nŒ≥_noise::Any: parameter of the diffusion process to scale the variance. Default: 1.0\nmollifier::Any: mollifier. Default: Base.Fix2(softplus, 10)\nd_mollifier::Any: differential of mollifier. Default: Base.Fix2(‚àÇsoftplus, 10)\nadaptive::Bool: Fixed time step? Default: false\n\nConstructor\n\nExample for Float32: Diffusion(Œ≥ = 1f0). If you want Float64, you have to pass the two scalars\n\n```Diffusion(Œ≥ = 1.0, Œ≥_noise = 1.0)```\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.Transport","page":"Library","title":"Tractography.Transport","text":"Define a transport algorithm. Options are the same as for Diffusion.\n\nArguments (with default values):\n\nŒ≥::Any: Œ≥ parameter of the diffusion process. It is related to the curvature of the streamline. Default: 1.0\nmollifier::Any: mollifier. Default: Base.Fix2(softplus, 10)\nd_mollifier::Any: differential of mollifier. Default: Base.Fix2(‚àÇsoftplus, 10)\nadaptive::Bool: Fixed time step? Default: false\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.Connectivity","page":"Library","title":"Tractography.Connectivity","text":"struct Connectivity{Talg} <: Tractography.AbstractSampler\n\nTractography based sampling of structural connectivity.  Do not compute the full streamline but only return the first/last points and the streamlines lengths. This allows to compute many more streamlines on GPU where memory is limited.\n\nConstructor example\n\nConnectivity(Probabilistic())\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.init","page":"Library","title":"Tractography.init","text":"init(\n    model::TMC{ùíØ},\n    alg;\n    n_sphere,\n    ùíØ‚Çê\n) -> Tractography.ThreadedCache{_A, Nothing, _B, Nothing, Nothing} where {_A, _B}\n\n\nCreate a cache for computing streamlines in batches. This is interesting for use of memory limited environments (e.g. on GPU).\n\ntip: Tip\nUse it with sample!\n\nArguments\n\nalg sampling algorithm, Deterministic, Probabilistic, Diffusion, etc.\nn_sphere::Int = 400 number of points to discretize the sphere on which we evaluate the spherical harmonics.\nùíØ‚Çê = Array{ùíØ} specify the type of the arrays in the cache. If passed a GPU array type like CuArray for CUDA, the sampling occurs on the GPU. Leave it for computing on CPU.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.sample","page":"Library","title":"Tractography.sample","text":"sample(\n    model::TMC{ùíØ},\n    alg::Tractography.AbstractSampler,\n    seeds::AbstractArray{ùíØ, 2};\n    ...\n) -> Tuple{Any, Any}\nsample(\n    model::TMC{ùíØ},\n    alg::Tractography.AbstractSampler,\n    seeds::AbstractArray{ùíØ, 2},\n    mask::Union{Nothing, AbstractArray{Bool}};\n    nt,\n    n_sphere,\n    maxfod_start,\n    reverse_direction,\n    nthreads,\n    gputhreads,\n    saveat\n) -> Tuple{Any, Any}\n\n\nSample the TMC model.\n\nArguments\n\nmodel::TMC\nalg sampling algorithm, Deterministic, Probabilistic, Diffusion, etc.\nseeds matrix of size 6 x Nmc where Nmc is the number of Monte-Carlo simulations to be performed.\nmask = nothing matrix of boolean where to stop computation. See also _apply_mask.\n\nOptional arguments\n\nnt::Int maximal number of steps to compute each streamline.\nn_sphere::Int = 400 number of points to discretize the sphere on which we evaluate the spherical harmonics.\nmaxfod_start::Bool for each locations, use direction provided by the argmax of the ODF.\nreverse_direction::Bool reverse initial direction.\nnthreads::Int = 8 number of threads on CPU.\ngputhreads::Int = 512 number of threads on GPU.\nsaveat::Int record the streamline every saveat step. Only available for alg <: Diffusion.\n\nOutput\n\nstreamlines with shape 3 x nt x Nmc\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.sample!","page":"Library","title":"Tractography.sample!","text":"sample!(\n    streamlines,\n    streamlines_length,\n    model::TMC{ùíØ},\n    cache::Tractography.AbstractCache,\n    alg,\n    seeds;\n    maxfod_start,\n    reverse_direction,\n    nthreads,\n    gputhreads,\n    n‚Çú,\n    saveat,\n    ùíØ‚Çê\n) -> Any\n\n\nSample the TMC model inplace by overwriting result. This requires very little memory and can be run indefinitely on the GPU for example.\n\nArguments\n\nstreamlines array with shape 3 x nt x Nmc. nt is maximal length of each streamline. Nmc is the number of Monte-Carlo simulations to be performed.\nstreamlines_length length of the streamlines\nmodel::TMC \nalg sampling algorithm, Deterministic, Probabilistic, Diffusion, etc.\nseeds matrix of size 6 x Nmc where Nmc is the number of Monte-Carlo simulations to be performed.\n\nOptional arguments\n\nmaxfod_start::Bool for each locations, use direction provided by the argmax of the ODF.\nreverse_direction::Bool reverse initial direction.\nnthreads::Int = 8 number of threads on CPU.\ngputhreads::Int = 512 number of threads on GPU.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.plot_streamlines!","page":"Library","title":"Tractography.plot_streamlines!","text":"plot_streamlines!(ax, streamlines; k...)\n\n\nPlot the streamlines.\n\nThe optional parameters are passed to lines!\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.plot_fod!","page":"Library","title":"Tractography.plot_fod!","text":"plot_fod!(ax, model; n_sphere, radius, st, I, J, K, c0min)\n\n\nPlot the the ODF with glyphs.\n\nSee also\n\nplot_fod(model; kwargs...)\n\nArguments\n\nmodel::TMC\nI, J, K range for displaying the ODF. Some of them can be a single element, like K = 40:40.\nradius radius of the glyph.\nst = 4 stride, only show one over st glyph in each direction.\n\nOptional arguments\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.plot_slice","page":"Library","title":"Tractography.plot_slice","text":"plot_slice(model; k...)\n\n\nPlot a slice of the data.\n\nSee also\n\nplot_slice!\n\nArguments\n\nmodel::TMC\n\nOptional arguments\n\nodf::Bool display the ODF with glyphs.\nslice::Bool display the brain slice from mean ODF value.\ninterpolate::Bool interpolate the brain slice (reduces pixelization).\nalpha alpha value for brain slice.\nI,J,K range for displaying the ODF. One of them should be a single element, like K = 40:40.\nst::Int = 2\nc0min minimum mean ODF value for plotting the glyph.\nn_theta::Int number of points for showing the glyphs.\nradius = 0.1 radius of the glyphs.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.Cone","page":"Library","title":"Tractography.Cone","text":"struct Cone{ùíØ<:Real}\n\nStructure to encode a cone to limit sampling the direction.  This ensures that the angle in degrees between to consecutive streamline directions is less than angle.\n\nThe implemented condition is for cn = Cone(angle).\n\n(cn::Cone)(d1, d2) = dot(d1, d2) > cosd(cn.alpha)\n\nFields\n\nalpha::Real: half section angle in degrees\n\nConstructor\n\nCone(angle)\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography._apply_mask!","page":"Library","title":"Tractography._apply_mask!","text":"_apply_mask!(model, mask)\n\n\nMultiply the mask which is akin to a matrix of Bool with same size as the data stored in model. Basically, the mask mask[ix, iy, iz] ensures whether the voxel (ix, iy, iz) is discarded or not.\n\nArguments\n\nmodel::TMC.\nmask can be a AbstractArray{3, Bool} or a NIVolume.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.Expùïä¬≤","page":"Library","title":"Tractography.Expùïä¬≤","text":"Expùïä¬≤(p, X, t)\n\n\nExponential map on the sphere.\n\nWe assume that t>0\n\nSee https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/5c4a61ed3e5e44755a22f7872cb296a621905f87/test/ManifoldsBaseTestUtils.jl#L63\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.spherical_to_euclidean","page":"Library","title":"Tractography.spherical_to_euclidean","text":"spherical_to_euclidean(Œ∏, œï)\n\n\nTransform spherical to cartesian coordinates.\n\nRecall that t‚àà[0, œÄ] and p‚àà[0, 2œÄ]\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.euclidean_to_spherical","page":"Library","title":"Tractography.euclidean_to_spherical","text":"euclidean_to_spherical(x, y, z)\n\n\nTransform cartesian to spherical coordinates. Assume that the vector has norm one.\n\n\n\n\n\n","category":"function"},{"location":"algos/#algos","page":"Algorithms","title":"Tractography algorithms","text":"Pages = [\"algos.md\"]\nDepth = 3\n\nThe library provides several algorithms to compute the streamlines. More precisely, assume that we are given a field of fibre orientation distribution (FOD) \n\nbm uto ODF(bm xbm u)\n\nwhere ODF(bm xcdot) is the distribution of directions at position bm x.\n\nIn practice, to prevent sharp direction changes, the full FOD is not considered at a given step. Typically, a new direction is obtained by sampling the FOD in a cone around the previous direction.  This can represented as a modification of the incoming direction bmu in mathbbS^2\n\ng(bmx bmu bmu) = frac1N(bmx bmu)f(bmx bmu)c(bmu bmu)\n\nwhere c(bmu bmu) in mathbbR^+ is non‚Äìzero in a cone around bmu and N(bmx bmu) in mathbbR^+ is a normalization factor that ensures\n\nint_mathbbS^2g(bmx bmu bmu)dbmu = 1\n\ntip: Cone\nThe cone function is passed to a TMC via Tractography.TMC. The TMC also determine how the FOD are computed, see SH evaluation.","category":"section"},{"location":"algos/#1.-Deterministic","page":"Algorithms","title":"1. Deterministic","text":"The algorithm alg = Deterministic() (see Tractography.Deterministic) implements the following situation. We compute a sequence (bm x_i bm u_i)_i such that\n\nbm x_i+1 = bm x_i + Delta s bm u_i\n\nbm u_i+1 = argmax g(bm x_i cdot)","category":"section"},{"location":"algos/#2.-Probabilistic","page":"Algorithms","title":"2. Probabilistic","text":"The algorithm alg = Probabilistic() (see Tractography.Probabilistic) implements the following situation. We compute a sequence (bm x_i bm u_i)_i such that\n\nbm x_i+1 = bm x_i + Delta s bm u_i\n\nbm u_i+1 sim g(bm x_i bm u_i cdot)","category":"section"},{"location":"algos/#3.-Diffusion","page":"Algorithms","title":"3. Diffusion","text":"The algorithm alg = Diffusion() (see Tractography.Diffusion) implement the following situation. It computes solution to the stochastic differential equation (SDE):\n\ndbm x_t‚Çú = bm u_t dt\n\ndbm u_t‚Çú = Œ≥ cdot nablalog ODF(bmx_t bm u_t) dt + gamma_noise cdot sqrtgamma cdot dB_t","category":"section"},{"location":"algos/#4.-Transport","page":"Algorithms","title":"4. Transport","text":"Same as Diffusion but with gamma_noise = 0.","category":"section"},{"location":"plot/#Plotting","page":"Plotting","title":"Plotting","text":"Plotting functionality is provided through Makie.jl recipes. By loading one of the Makie backends (CairoMakie, GLMakie, or WGLMakie), you can use custom functions to visualize FOD (Fiber Orientation Distribution) data.\n\nThis tutorial uses CairoMakie for static plots, but GLMakie is recommended for interactive 3D visualization.","category":"section"},{"location":"plot/#Setup","page":"Plotting","title":"Setup","text":"Let's start by loading FOD data from a NIfTI file:\n\nusing Tractography\nconst TG = Tractography\n\nmodel = TG.TMC(Œît = 0.125f0,\n            foddata = TG.FODData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            cone = TG.Cone(15f0),\n            proba_min = 0.005f0,\n            )","category":"section"},{"location":"plot/#Plotting-FODFs","page":"Plotting","title":"Plotting FODFs","text":"To visualize Fiber Orientation Distribution Functions (FODFs), use the plot_fod! function. See the plot_fod! documentation for details on available keyword arguments.\n\nThe following example plots FODFs for a specific region of interest:\n\nusing CairoMakie\nf, sc = TG.plot_fod(model; n_sphere = 1500, radius = 1., I = 29:31, J = 30:31, K = 2:2);\ncam3d = Makie.cameracontrols(sc) # hide\ncam3d.eyeposition[] = Vec3f(96.91587149289712, 85.36944962225634, -85.12319118529459)  # hide\ncam3d.lookat[] = Vec3f(95.90360332812566, 85.36944962225634, 2.943478780350152)  # hide\ncam3d.upvector[] = Vec3f(0.9999339466437674, 0.0, 0.01149357861675617)  # hide\nMakie.zoom!(sc.scene, cam3d, 0.10f0)  # hide\nf","category":"section"},{"location":"plot/#Plotting-Streamlines","page":"Plotting","title":"Plotting Streamlines","text":"To visualize tractography streamlines, use the plot_streamlines! function. See the plot_streamlines! documentation for details on available keyword arguments.\n\nThe following example creates synthetic streamlines and plots them alongside FODFs:\n\n# Generate synthetic streamlines for demonstration\nstreamlines = zeros(Float32, 6, 100, 20)\nfor n = 1:20\n    v0 = rand(3) * 15  # Random starting position\n    for nt = 1:100\n        # Create curved trajectories\n        streamlines[1:3, nt, n] .= v0 .+ nt .* [1, 1 + 0.1*rand(), 0]\n    end\nend\n\n# Create a combined visualization of streamlines and FODFs\nf = Figure(backgroundcolor = :white)\nlscene = LScene(f[1, 1])\nTG.plot_streamlines!(lscene.scene, streamlines[1:3, 1:1:end, :])\nTG.plot_fod!(lscene, model; n_sphere = 1500, radius = 1.3, st = 4)\nf","category":"section"},{"location":"seeds/#Generating-Seeds","page":"Generating Seeds","title":"Generating Seeds","text":"Seeds are starting points for tractography streamlines. Tractography.jl provides two main methods for generating seeds:","category":"section"},{"location":"seeds/#From-FOD-Data","page":"Generating Seeds","title":"From FOD Data","text":"Generate seeds directly from Fiber Orientation Distribution (FOD) data using Tractography.from_fod. This method places seeds throughout the FOD volume, typically in voxels with significant fiber content.\n\nusing Tractography\nconst TG = Tractography\n\n# Load FOD data\nmodel = TG.TMC(\n    foddata = TG.FODData(\"path/to/fod.nii.gz\"),\n    # other arguments ...\n)\n\n# Generate 100 seeds from FOD\nseeds = TG.from_fod(model, 100)","category":"section"},{"location":"seeds/#From-Mask","page":"Generating Seeds","title":"From Mask","text":"Generate seeds from a binary or labeled mask using Tractography.from_mask. This method is useful when you want to restrict seeding to specific anatomical regions.\n\n# Generate 100 seeds from a mask array\nmask = # your mask array (3D binary or labeled volume)\nseeds = TG.from_mask(model, mask, 100)","category":"section"},{"location":"seeds/#Seed-Format","page":"Generating Seeds","title":"Seed Format","text":"Seeds are typically represented as a matrix where each column contains the (x, y, z, ux, uy, uz) coordinates of a seed point in voxel space.","category":"section"},{"location":"export/#Exporting-Tractography-Results","page":"Exporting Tractography Results","title":"Exporting Tractography Results","text":"After computing a tractogram, you can export streamlines to the TCK file format for use with other neuroimaging tools like MRtrix3, TrackVis, etc.","category":"section"},{"location":"export/#Saving-to-TCK-Format","page":"Exporting Tractography Results","title":"Saving to TCK Format","text":"The TCK format is a widely-used binary format for storing tractography streamlines. Tractography.jl provides a convenience function save_streamlines that uses the Python library nibabel via PythonCall.jl to export streamlines.","category":"section"},{"location":"export/#Prerequisites","page":"Exporting Tractography Results","title":"Prerequisites","text":"Ensure you have PythonCall.jl installed and nibabel available in your Python environment:\n\nusing Pkg\nPkg.add(\"PythonCall\")\n\nThen install nibabel in Python (this typically happens automatically via PythonCall).","category":"section"},{"location":"export/#Basic-Example","page":"Exporting Tractography Results","title":"Basic Example","text":"using Tractography\nusing PythonCall\nconst TG = Tractography\n\n# ... model definition skipped\nstreamlines, tract_length = TG.sample(model, alg_tracking, seeds)\n\n# Export to TCK file\nTG.save_streamlines(\"my_tractogram.tck\", streamlines, tract_length)","category":"section"},{"location":"export/#Output-Format","page":"Exporting Tractography Results","title":"Output Format","text":"The saved TCK file contains:\n\nStreamline coordinates: 3D positions of points along each fiber tract\n\nThe file can be visualized and analyzed using standard tractography software.","category":"section"},{"location":"getstart/#Get-started-with-with-Tractography.jl","page":"Getting started","title":"üöÄ Get started with with Tractography.jl","text":"Pages = [\"getstart.md\"]\nDepth = 3\n\nThis tutorial will introduce you to the functionalities for computing streamlines.","category":"section"},{"location":"getstart/#Basic-use","page":"Getting started","title":"Basic use","text":"In this example, we will sample Nmc streamlines from a Tractography Markov Chain (TMC).\n\nusing Tractography\nconst TG = Tractography\n\nmodel = TMC(Œît = 0.125f0,\n            foddata = FODData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            )\nNmc = 10\nseeds = rand(Float32, 6, Nmc)\nalg = Probabilistic()\nstreamlines, tract_length = sample(model, alg, seeds);\nsize(streamlines)","category":"section"},{"location":"getstart/#Step-1:-Define-a-TMC","page":"Getting started","title":"Step 1: Define a TMC","text":"We define a Tractography Markov Chain (TMC) model as follows:\n\nmodel = TMC(Œît = 0.125f0,\n            foddata = FODData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            )","category":"section"},{"location":"getstart/#Step-2:-Define-the-seeds","page":"Getting started","title":"Step 2: Define the seeds","text":"Nmc = 10 # Monte Carlo sample\nseeds = rand(Float32, 6, Nmc)","category":"section"},{"location":"getstart/#Step-3:-Chose-a-sample-algorithm","page":"Getting started","title":"Step 3: Chose a sample algorithm","text":"alg = Probabilistic()","category":"section"},{"location":"getstart/#Step-4:-Sample-the-streamlines","page":"Getting started","title":"Step 4: Sample the streamlines","text":"streamlines, tract_length = sample(model, alg, seeds);","category":"section"},{"location":"getstart/#Optimal-use","page":"Getting started","title":"Optimal use","text":"It is often better to cache some data when computing batches of streamlines. This would be done as follows\n\nmodel = TMC(Œît = 0.125f0,\n            foddata = FODData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            )\nNmc = 10\nseeds = rand(Float32, 6, Nmc)\nstreamlines = zeros(Float32, 6, 20, Nmc)\ntract_length = zeros(UInt32, Nmc)\nalg = Probabilistic()\ncache = TG.init(model, alg)\n# this can be called repeatedly after updating seeds for example\nTG.sample!(streamlines, tract_length, model, cache, alg, seeds);\nsize(streamlines)","category":"section"},{"location":"overview-cap/#Overview-of-capabilities","page":"Overview of capabilities","title":"Overview of capabilities","text":"A complete streamline generation workflow typically involves the following steps:\n\nEstimating fibre orientation distributions (FODs)  \nGenerating seeds from the estimated FODs  \nRunning tractography algorithms to produce streamlines  \n\nThe Tractography.jl package focuses on steps 2 and 3.   Step 1 ‚Äî estimating FODs ‚Äî should be performed using a dedicated library, such as Fibers.jl.\n\n","category":"section"},{"location":"overview-cap/#FOD-specification","page":"Overview of capabilities","title":"FOD specification","text":"The FOD can be supplied to the Tractography Markov Chain (TMC) by the keyword argument foddata. See Tractography.TMC for more details. Now, you can pass to foddata a Tractography.FODData object (see Tractography.FODData for more information), which can be created:\n\nfrom a NIfTI file using the simplified Tractography.FODData constructor.\nfrom an AbstractArray object using directly the Tractography.FODData constructor.\n\n","category":"section"},{"location":"overview-cap/#Seed-Generation","page":"Overview of capabilities","title":"Seed Generation","text":"Seeds can be generated directly from the FOD or from a binary mask using the following methods:\n\nTractography.from_fod  \nTractography.from_mask\n\n","category":"section"},{"location":"overview-cap/#Tracking-Algorithms","page":"Overview of capabilities","title":"Tracking Algorithms","text":"Four tracking algorithms are currently implemented (see Algorithms).  \nAll algorithms can run on either GPU or CPU (threaded), and are vendor-agnostic.  \nThe interface supports precomputed caches, making the algorithms allocation-free during execution. This allows for efficient, long-duration runs.  \nComputations support arbitrary floating-point precision (Float32, Float64, BigFloat, ...).\n\n","category":"section"},{"location":"overview-cap/#Plotting","page":"Overview of capabilities","title":"Plotting","text":"The package provides convenient plotting utilities to:\n\nVisualize streamlines  \nDisplay FODs using glyph-based representations  \n\n","category":"section"},{"location":"overview-cap/#Exporting-Streamlines","page":"Overview of capabilities","title":"Exporting Streamlines","text":"Generated streamlines can be exported in the .tck format.   Alternatively, users can export data to any preferred format using standard Julia packages (e.g. JLD2.jl).","category":"section"},{"location":"gpu/#GPU-example","page":"GPU example","title":"GPU example","text":"Here is an example which works on GPU. The implementation is agnostic to the GPU vendor but we focus on NVIDIA for this example.\n\nTo speed up computations, we restrict to Float32, this is handled easily by the package.\n\ndanger: Danger\nBecause allocations matter a lot on GPU, we pre-allocate all the memory required for computations and fill this inplace.\n\nusing Tractography\nconst TG = Tractography\n\n# define the model for TMC\nmodel = TMC(Œît = 0.125f0,\n            foddata = FODData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            cone = Cone(45f0),\n            proba_min = 0.005f0,\n            )","category":"section"},{"location":"gpu/#Define-the-seeds","page":"GPU example","title":"Define the seeds","text":"using CUDA\n# number of streamlines\nNmc = 1024*400\n# maximum number of steps for each streamline\nNt = 2000\n# define the seeds\nseeds = cu(zeros(6, Nmc));\nseeds[1:3, :] .= [-13.75, 26.5, 8] .+ 0.1  .* randn(3, Nmc) .|> Float32 |> CuArray;\nseeds[4, :] .= 1\ntract_length = CuArray((zeros(UInt32, Nmc))\n\nwe next define a buffer to hold the streamlines\n\nstreamlines_gpu = cu(zeros(Float32, 3, Nt, Nmc), unified = true)","category":"section"},{"location":"gpu/#Define-the-computation-cache","page":"GPU example","title":"Define the computation cache","text":"Because we can compute the streamlines in batches for the same TMC, it is best to cache some data for this\n\n# we precompute the cache which is heavy otherwise each call to sample\n# will recompute it\ncache_g = TG.init(model, Probabilistic(); \n                  ùíØ‚Çê = CuArray,\n                  n_sphere = 400);","category":"section"},{"location":"gpu/#Compute-the-streamlines","page":"GPU example","title":"Compute the streamlines","text":"The following takes 0.5s on a A100.\n\n# this setup works for a GPU with 40GiB\n# it yields 1e6/sec streamlines for Probabilistic\n# and 2.2e6/sec streamlines for Deterministic\nCUDA.@time TG.sample!(\n            streamlines_gpu,\n            tract_length,\n            model,\n            cache_g,\n            Probabilistic(),\n            seeds;\n            gputhreads = 1024,\n            );\n\ntip: batches\nThis can be called many times, for example after updating the seeds.\n\nSo far the streamlines streamlines_gpu are on the GPU. We can retrieve them at zero cost on the CPU\n\nstreamlines = @time unsafe_wrap(Array, streamlines_gpu);","category":"section"},{"location":"#Tractography.jl","page":"Home","title":"Tractography.jl","text":"Tractography.jl is a high-performance Julia package for brain tractography that leverages parallel computing and specialized hardware (e.g., GPUs) to reconstruct white matter fiber bundles from diffusion-weighted MRI data. This enables researchers to study the structural connectivity of the brain at unprecedented scales.\n\n(Image: )","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"GPU acceleration: Massive parallelization for processing billions of streamlines\nMultiple tracking algorithms: Including stochastic methods\nFlexible seeding: Generate seeds from FOD data or anatomical masks\nVisualization: Built-in plotting recipes for Makie.jl\nExport capabilities: Save tractograms to standard TCK format\nHigh performance: Successfully used to sample 500 billion streamlines on GPU","category":"section"},{"location":"#Installation","page":"Home","title":"üì¶ Installation","text":"Assuming you have Julia installed, add Tractography.jl using the package manager:\n\nimport Pkg\nPkg.add(\"Tractography\")","category":"section"},{"location":"#Citing-this-work","page":"Home","title":"üìö Citing this work","text":"To come...","category":"section"},{"location":"#Related-Software","page":"Home","title":"üßë‚Äçüíª Related Software","text":"Similar algorithms are implemented in the Python package:\n\nCronos Tractography\n\nSeveral excellent tractography software packages are available and listed on the IST website:\n\nDIPY - Comprehensive diffusion MRI analysis in Python\nDSI Studio - Diffusion MRI analysis tool\nEntrack - Deep learning-based tractography\nExploreDTI - DTI and HARDI analysis toolbox\nMRtrix3 - Leading software for diffusion MRI analysis (lacks GPU support)\nScilpy - Python tools for diffusion MRI processing\nTrekker - Fast parallel tractography","category":"section"},{"location":"#Julia-Ecosystem","page":"Home","title":"Julia Ecosystem","text":"Tractography.jl is currently the only Julia package focused specifically on tractography. Related Julia packages include:\n\nFibers.jl - Tools for diffusion MRI data\nMicrostructure.jl - Microstructure modeling\nNeuroFormats.jl - Neuroimaging file format support\nJuliaNeuroscience - Neuroscience tools organization","category":"section"},{"location":"#Performance","page":"Home","title":"Performance","text":"The examples in this documentation prioritize clarity and simplicity over maximum performance. However, Tractography.jl is capable of extreme-scale tractography.","category":"section"},{"location":"#Proven-at-Scale","page":"Home","title":"Proven at Scale","text":"This package was used to sample 500 billion streamlines on GPU for a recent publication:\n\nYanis Aeschlimann, Samuel Deslauriers-Gauthier, Romain Veltz. GPU tractography: What can we learn from half a trillion streamlines? International Society for Tractography Conference - IST 2025, Oct 2025, Bordeaux, France. ‚ü®hal-05272265‚ü©\n\nThis demonstrates the package's capability to handle production-scale neuroimaging research with GPU acceleration.","category":"section"}]
}
