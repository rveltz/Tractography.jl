var documenterSearchIndex = {"docs":
[{"location":"getstart/#Get-started-with-with-Tractography.jl","page":"Getting started","title":"üöÄ Get started with with Tractography.jl","text":"","category":"section"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"Pages = [\"getstart.md\"]\nDepth = 3","category":"page"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"This tutorial will introduce you to the functionalities for computing streamlines.","category":"page"},{"location":"getstart/#Basic-use","page":"Getting started","title":"Basic use","text":"","category":"section"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"In this example, we will sample Nmc streamlines from a Tractography Markov Chain (TMC).","category":"page"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"using Tractography\nconst TG = Tractography\n\nmodel = TMC(Œît = 0.125f0,\n            odfdata = ODFData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            )\nNmc = 10\nseeds = rand(Float32, 6, Nmc)\nalg = Probabilistic()\nstreamlines, tract_length = sample(model, alg, seeds);\nsize(streamlines)","category":"page"},{"location":"getstart/#Step-1:-Define-a-TMC","page":"Getting started","title":"Step 1: Define a TMC","text":"","category":"section"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"We define a Tractography Markov Chain (TMC) model as follows:","category":"page"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"model = TMC(Œît = 0.125f0,\n            odfdata = ODFData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            )","category":"page"},{"location":"getstart/#Step-2:-Define-the-seeds","page":"Getting started","title":"Step 2: Define the seeds","text":"","category":"section"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"Nmc = 10 # Monte Carlo sample\nseeds = rand(Float32, 6, Nmc)","category":"page"},{"location":"getstart/#Step-3:-Chose-a-sample-algorithm","page":"Getting started","title":"Step 3: Chose a sample algorithm","text":"","category":"section"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"alg = Probabilistic()","category":"page"},{"location":"getstart/#Step-4:-Sample-the-streamlines","page":"Getting started","title":"Step 4: Sample the streamlines","text":"","category":"section"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"streamlines, tract_length = sample(model, alg, seeds);","category":"page"},{"location":"getstart/#Optimal-use","page":"Getting started","title":"Optimal use","text":"","category":"section"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"It is often better to cache some data when computing batches of streamlines. This would be done as follows","category":"page"},{"location":"getstart/","page":"Getting started","title":"Getting started","text":"model = TMC(Œît = 0.125f0,\n            odfdata = ODFData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            )\nNmc = 10\nseeds = rand(Float32, 6, Nmc)\nstreamlines = zeros(Float32, 6, 20, Nmc)\ntract_length = zeros(UInt32, Nmc)\nalg = Probabilistic()\ncache = TG.init(model, alg)\n# this can be called repeatedly after updating seeds for example\nTG.sample!(streamlines, tract_length, model, cache, alg, seeds);\nsize(streamlines)","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Misc","page":"Library","title":"Misc","text":"","category":"section"},{"location":"library/#Tractography.Cone","page":"Library","title":"Tractography.Cone","text":"struct Cone{ùíØ<:Real}\n\nStructure to encode a cone to limit sampling the direction.  This ensures that the angle in degrees between to consecutive streamline directions is less than angle.\n\nThe implemented condition is for cn = Cone(angle)\n\n(cn::Cone)(d1, d2) = dot(d1, d2) > cosd(cn.alpha)\n\nFields\n\nalpha::Real: half section angle in degrees\n\nConstructor\n\nCone(angle)\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography._apply_mask!","page":"Library","title":"Tractography._apply_mask!","text":"_apply_mask!(model, mask)\n\n\nMultiply the mask which is akin to a matrix of Bool with same size as the data stored in model. Basically, the mask mask[ix, iy, iz] ensures whether the voxel (ix, iy, iz) is discarded or not.\n\nArguments\n\nmodel::TMC.\nmask can be a AbstractArray{3, Bool} or a NIVolume.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.Expùïä¬≤","page":"Library","title":"Tractography.Expùïä¬≤","text":"Expùïä¬≤(p, X, t)\n\n\nExponential map on the sphere.\n\nWe assume that t>0\n\nSee https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/5c4a61ed3e5e44755a22f7872cb296a621905f87/test/ManifoldsBaseTestUtils.jl#L63\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.spherical_to_euclidean","page":"Library","title":"Tractography.spherical_to_euclidean","text":"spherical_to_euclidean(Œ∏, œï)\n\n\nTransform spherical to cartesian coordinates.\n\nRecall that t‚àà[0, œÄ] and p‚àà[0, 2œÄ]\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.euclidean_to_spherical","page":"Library","title":"Tractography.euclidean_to_spherical","text":"euclidean_to_spherical(x, y, z)\n\n\nTransform cartesian to spherical coordinates. Assume that the vector has norm one.\n\n\n\n\n\n","category":"function"},{"location":"library/#sheval","page":"Library","title":"Spherical harmonics evaluation strategy","text":"","category":"section"},{"location":"library/#Tractography.PlottingSH","page":"Library","title":"Tractography.PlottingSH","text":"struct PlottingSH <: Tractography.AbstractSPHEvaluation\n\nSet up for plotting ODF.\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.PreComputeAllODF","page":"Library","title":"Tractography.PreComputeAllODF","text":"struct PreComputeAllODF <: Tractography.AbstractSPHEvaluation\n\nSpherical harmonics evaluation based on Fibonacci sampling. All ODF are pre-computed once and saved in a cache. Their positivity is enforced with a max(0,‚ãÖ) or a mollifier. \n\ndanger: Danger\nRequires a relatively large memory!\n\nDetails\n\nIf you have na angles for sampling the unit sphere and the data is of size (nx, ny, nz, nsph), it yields a matrix of dimensions (nx, ny, nz, na).\n\n\n\n\n\n","category":"type"},{"location":"library/#Models","page":"Library","title":"Models","text":"","category":"section"},{"location":"library/#Tractography.TMC","page":"Library","title":"Tractography.TMC","text":"struct TMC{ùíØ, ùíØalg<:Tractography.AbstractSPHEvaluation, ùíØd, ùíØC, ùíØmol}\n\nTractography Markov Chain (TMC).\n\nFields (with default values):\n\nŒît::Any: Step size of the TMC. Default: 0.1\nevaluation_algo::Tractography.AbstractSPHEvaluation: Spherical harmonics evaluation algorithm. Can be FibonacciSH(), PreComputeAllODF(). Default: PreComputeAllODF()\nodfdata::Any: ODF data from nifti file. Must be the list of ODF in the base of spherical harmonics. Hence, it should be an (abstract) 4d array. Default: nothing\ncone::Any: Cone function to restrict angle diffusion. You can use a Cone or a custom function (d1, d2) -> return_a_boolean. Default: Cone(90.0f0)\nproba_min::Any: Probability below which we stop tracking. Default: 0.0\nmollifier::Any: Mollifier, used to make the fodf non negative. During odf evaluation, we effectively use mollifier(fodf[i,j,k,angle]). Default: default_mollifier\n\nMethods\n\n_apply_mask!(model, mask) apply a mask to the raw SH tensor. See its doc string.\n_getdata(model) return the fodf data associated with the TMC.\nsize(model) return nx, ny, nz, nt.\neltype(model) return the scalar type of the data (default Float64).\nget_lmax(model) return the max l coordinate in of spherical harmonics.\n\nConstructors (use the fields!)\n\nTMC()\nTMC(Œît = 0.1f0) for a Float32 TMC\nTMC(Œît = 0.1, proba_min = 0.) for a Float64 TMC. You need to specify both fields Œît and proba_min\nTMC(odfdata = rand(10,10,10,45)) for custom ODF\n\n\n\n\n\n","category":"type"},{"location":"library/#Algorithms","page":"Library","title":"Algorithms","text":"","category":"section"},{"location":"library/#Tractography.Deterministic","page":"Library","title":"Tractography.Deterministic","text":"struct Deterministic <: Tractography.DeterministicSampler\n\nTractography sampling performed with the argmax function. Can be used with FibonacciSH and PreComputeAllODF.\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.Probabilistic","page":"Library","title":"Tractography.Probabilistic","text":"struct Probabilistic <: Tractography.AbstractNotPureRejectionSampler\n\nTractography sampling performed with the cumulative sum distribution. Can be used with FibonacciSH and PreComputeAllODF.\n\nConstructor\n\nProbabilistic()\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.Diffusion","page":"Library","title":"Tractography.Diffusion","text":"struct Diffusion{Ta, T, Tk, Tmol, Tdmol} <: Tractography.AbstractSampler\n\nTractography sampling performed with diffusive model. Basically, the streamlines (X‚Çú)‚Çú are solution of the SDE\n\ndX‚Çú = Œ≥ * drift dt + Œ≥_noise * ‚àöŒ≥ * dnoise‚Çú\n\nArguments (with default values):\n\nalg_sde::Any: SciML algorithm used to simulate the tractography diffusion process. Default: nothing\nŒ≥::Any: Œ≥ parameter of the diffusion process. Default: 1.0\nŒ≥_noise::Any: parameter of the diffusion process to scale the variance. Default: 1.0\nkw_sde::Any: keyword arguments passed to alg_sde. Default: nothing\nmollifier::Any: mollifier. Default: Base.Fix2(softplus, 10)\nd_mollifier::Any: differential of mollifier. Default: Base.Fix2(‚àÇsoftplus, 10)\nadaptive::Bool: Fixed time step? Default: false\n\nConstructor\n\nExample for Float32: Diffusion(Œ≥ = 1f0). If you want Float64, you have to pass the two scalars\n\n```Diffusion(Œ≥ = 1.0, Œ≥_noise = 1.0)```\n\n\n\n\n\n","category":"type"},{"location":"library/#Tractography.Connectivity","page":"Library","title":"Tractography.Connectivity","text":"struct Connectivity{Talg} <: Tractography.AbstractSampler\n\nTractography based sampling of structural connectivity.  Do not compute the full streamline but only return the first/last points and the streamlines lengths. This allows to compute many more streamlines on GPU where memory is limited.\n\nConstructor example\n\nConnectivity(Probabilistic())\n\n\n\n\n\n","category":"type"},{"location":"library/#Sampling","page":"Library","title":"Sampling","text":"","category":"section"},{"location":"library/#Tractography.init","page":"Library","title":"Tractography.init","text":"init(\n    model::TMC{ùíØ},\n    alg;\n    n_sphere,\n    ùíØ‚Çê\n) -> Tractography.ThreadedCache{_A, Nothing, _B, Nothing, Nothing} where {_A, _B}\n\n\nCreate a cache for computing streamlines in batches. This is interesting for use of memory limited environments (e.g. on GPU).\n\ntip: Tip\nUse it with sample!\n\nArguments\n\nalg sampling algorithm, Deterministic, Probabilistic, Diffusion, etc.\nn_sphere::Int = 400 number of points to discretize the sphere on which we evaluate the spherical harmonics.\nùíØ‚Çê = Array{ùíØ} specify the type of the arrays in the cache. If passed a GPU array type like CuArray for CUDA, the sampling occurs on the GPU. Leave it for computing on CPU.\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.sample","page":"Library","title":"Tractography.sample","text":"sample(\n    model::TMC{ùíØ},\n    alg::Tractography.AbstractSampler,\n    seeds::AbstractArray{ùíØ, 2};\n    ...\n) -> Tuple{Any, Any}\nsample(\n    model::TMC{ùíØ},\n    alg::Tractography.AbstractSampler,\n    seeds::AbstractArray{ùíØ, 2},\n    mask::Union{Nothing, AbstractArray{Bool}};\n    nt,\n    n_sphere,\n    maxodf_start,\n    reverse_direction,\n    nthreads,\n    gputhreads,\n    saveat\n) -> Tuple{Any, Any}\n\n\nSample the TMC model.\n\nArguments\n\nmodel::TMC\nalg sampling algorithm, Deterministic, Probabilistic, Diffusion, etc.\nseeds matrix of size 6 x Nmc where Nmc is the number of Monte-Carlo simulations to be performed.\nmask = nothing matrix of boolean where to stop computation. See also _apply_mask.\n\nOptional arguments\n\nnt::Int maximal number of steps to compute each streamline.\nn_sphere::Int = 400 number of points to discretize the sphere on which we evaluate the spherical harmonics.\nmaxodf_start::Bool for each locations, use direction provided by the argmax of the ODF.\nreverse_direction::Bool reverse initial direction.\nnthreads::Int = 8 number of threads on CPU.\ngputhreads::Int = 512 number of threads on GPU.\nsaveat::Int record the streamline every saveat step. Only available for alg <: Diffusion.\n\nOutput\n\nstreamlines with shape 3 x nt x Nmc\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.sample!","page":"Library","title":"Tractography.sample!","text":"sample!(\n    streamlines,\n    streamlines_length,\n    model::TMC{ùíØ},\n    cache::Tractography.AbstractCache,\n    alg,\n    seeds;\n    maxodf_start,\n    reverse_direction,\n    nthreads,\n    gputhreads,\n    n‚Çú,\n    saveat,\n    ùíØ‚Çê\n) -> Any\n\n\nSample the TMC model inplace by overwriting result. This requires very little memory and can be run indefinitely on the GPU for example.\n\nArguments\n\nstreamlines array with shape 3 x nt x Nmc. nt is maximal length of each streamline. Nmc is the number of Monte-Carlo simulations to be performed.\nstreamlines_length length of the streamlines\nmodel::TMC \nalg sampling algorithm, Deterministic, Probabilistic, Diffusion, etc.\nseeds matrix of size 6 x Nmc where Nmc is the number of Monte-Carlo simulations to be performed.\n\nOptional arguments\n\nmaxodf_start::Bool for each locations, use direction provided by the argmax of the ODF.\nreverse_direction::Bool reverse initial direction.\nnthreads::Int = 8 number of threads on CPU.\ngputhreads::Int = 512 number of threads on GPU.\n\n\n\n\n\n","category":"function"},{"location":"library/#Plotting","page":"Library","title":"Plotting","text":"","category":"section"},{"location":"library/#Tractography.plot_streamlines!","page":"Library","title":"Tractography.plot_streamlines!","text":"plot_streamlines!(ax, streamlines; k...)\n\n\nPlot the streamlines.\n\nThe optional parameters are passed to lines!\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.plot_odf!","page":"Library","title":"Tractography.plot_odf!","text":"plot_odf!(ax, model; n_sphere, radius, st, I, J, K, c0min)\n\n\nPlot the the ODF with glyphs.\n\nSee also\n\nplot_odf(model; kwargs...)\n\nArguments\n\nmodel::TMC\nI, J, K range for displaying the ODF. Some of them can be a single element, like K = 40:40.\nradius radius of the glyph.\nst = 4 stride, only show one over st glyph in each direction.\n\nOptional arguments\n\n\n\n\n\n","category":"function"},{"location":"library/#Tractography.plot_slice","page":"Library","title":"Tractography.plot_slice","text":"plot_slice(model; k...)\n\n\nPlot a slice of the data.\n\nSee also\n\nplot_slice!\n\nArguments\n\nmodel::TMC\n\nOptional arguments\n\nodf::Bool display the ODF with glyphs.\nslice::Bool display the brain slice from mean ODF value.\ninterpolate::Bool interpolate the brain slice (reduces pixelization).\nalpha alpha value for brain slice.\nI,J,K range for displaying the ODF. One of them should be a single element, like K = 40:40.\nst::Int = 2\nc0min minimum mean ODF value for plotting the glyph.\nn_theta::Int number of points for showing the glyphs.\nradius = 0.1 radius of the glyphs.\n\n\n\n\n\n","category":"function"},{"location":"fcup/#FCUP","page":"FCUP","title":"FCUP","text":"","category":"section"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"Pages = [\"fcup.md\"]\nDepth = 3","category":"page"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"This is a more advanced tutorial because we want to show how to apply a mask.","category":"page"},{"location":"fcup/#Define-the-TMC","page":"FCUP","title":"Define the TMC","text":"","category":"section"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"import Tractography as TG\n\nmodel = TG.TMC(Œît = 0.125f0,\n            odfdata = TG.ODFData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            cone = TG.Cone(15),\n            proba_min = 0.005f0,\n            )","category":"page"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"Just for fun, we plot the FODF of the model.","category":"page"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"using CairoMakie\n\nf, sc = TG.plot_odf(model; n_sphere = 1500, radius = 0.3, st = 2);\ncam3d = Makie.cameracontrols(sc)\ncam3d.eyeposition[] = Vec3f(85, 95, -28)\ncam3d.lookat[] = Vec3f(84, 95, 59)\nrotate_cam!(sc.scene, 0, 0, -pi/2)\nf","category":"page"},{"location":"fcup/#Define-the-seeds","page":"FCUP","title":"Define the seeds","text":"","category":"section"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"We next apply a mask on the boundary of which the streamlines stop.","category":"page"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"using NIfTI\nmask = NIfTI.niread((@__DIR__) * \"/../../examples/wm-FC.nii.gz\");\nTG._apply_mask!(model, mask);","category":"page"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"We compute Nmc streamlines, hence we need Nmc seeds","category":"page"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"using LinearAlgebra\n\nNmc = 100_000\n_ind1 = findall(mask .== 1)\nseed_id = rand(1:length(_ind1), Nmc)\nseeds = zeros(Float32, 6, Nmc)\nfor i=1:Nmc\n    seeds[:,i] .= vcat(TG.transform(model.odfdata, _ind1[seed_id[i]])[1:3]..., normalize(randn(3)))\nend","category":"page"},{"location":"fcup/#Compute-the-streamlines","page":"FCUP","title":"Compute the streamlines","text":"","category":"section"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"streamlines, tract_length = TG.sample(model, TG.Deterministic(), seeds; nt = 1000);\nprintln(\"Dimension of computed streamlines = \", size(streamlines))","category":"page"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"f, sc = @time TG.plot_odf(model; n_sphere = 500, radius = 0.3, st = 2);\nTG.plot_streamlines!(sc, streamlines[1:3, 1:1:end, 1:10:Nmc])\nf","category":"page"},{"location":"fcup/#Compute-the-connections","page":"FCUP","title":"Compute the connections","text":"","category":"section"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"When computing structural connectivity, we don't need to record the entire streamline but only its extremities.","category":"page"},{"location":"fcup/","page":"FCUP","title":"FCUP","text":"streamlines, tract_length = TG.sample(model, TG.Connectivity(TG.Deterministic()), seeds; nt = 1000);\nprintln(\"Dimension of computed streamlines = \", size(streamlines))","category":"page"},{"location":"algos/#Tractography-algorithms","page":"Algorithms","title":"Tractography algorithms","text":"","category":"section"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"Pages = [\"algos.md\"]\nDepth = 3","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"The library provides several algorithms to compute the streamlines. More precisely, assume that we are given a field of fibre orientation distribution functions (FODF) ","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"bm uto ODF(bm xbm u)","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"where ODF(bm xcdot) is the distribution of directions at position bm x.","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"In practice, to prevent sharp direction changes, the full FODF is not considered at a given step. Typically, a new direction is obtained by sampling the FODF in a cone around the previous direction.  This can represented as a modification of the incoming direction bmu in mathbbS^2","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"g(bmx bmu bmu) = frac1N(bmx bmu)f(bmx bmu)c(bmu bmu)","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"where c(bmu bmu) in mathbbR^+ is non‚Äìzero in a cone around bmu and N(bmx bmu) in mathbbR^+ is a normalization factor that ensures","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"int_mathbbS^2g(bmx bmu bmu)dbmu = 1","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"tip: Cone\nThe cone function is passed to a TMC via Tractography.TMC. The TMC also determine how the FODF are computed, see SH evaluation.","category":"page"},{"location":"algos/#1.-Deterministic","page":"Algorithms","title":"1. Deterministic","text":"","category":"section"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"The algorithm alg = Deterministic() (see Tractography.Deterministic) implements the following situation. We compute a sequence (bm x_i bm u_i)_i such that","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"bm x_i+1 = bm x_i + Delta s bm u_i","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"bm u_i+1 = argmax g(bm x_i cdot)","category":"page"},{"location":"algos/#2.-Probabilistic","page":"Algorithms","title":"2. Probabilistic","text":"","category":"section"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"The algorithm alg = Probabilistic() (see Tractography.Probabilistic) implements the following situation. We compute a sequence (bm x_i bm u_i)_i such that","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"bm x_i+1 = bm x_i + Delta s bm u_i","category":"page"},{"location":"algos/","page":"Algorithms","title":"Algorithms","text":"bm u_i+1 sim g(bm x_i bm u_i cdot)","category":"page"},{"location":"plot/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"Plotting is provided by calling recipes to Makie.jl. Hence by loading CairoMakie or GLMakie or WGLMakie, you can use custom function to interact with FODF data. For this part, we use CairoMakie but the user is encouraged to use GLMakie instead.","category":"page"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"Let us start by reading some nii data.","category":"page"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"using Tractography\nconst TG = Tractography\n\nmodel = TG.TMC(Œît = 0.125f0,\n            odfdata = TG.ODFData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            cone = TG.Cone(15f0),\n            proba_min = 0.005f0,\n            )","category":"page"},{"location":"plot/#Plotting-the-FODFs","page":"Plotting","title":"Plotting the FODFs","text":"","category":"section"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"We rely on the function plot_odf! provides the information regarding the keyword arguments.","category":"page"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"using CairoMakie\nf, sc = TG.plot_odf(model; n_sphere = 1500, radius = 1., I = 29:31, J = 30:31, K = 2:2);\ncam3d = Makie.cameracontrols(sc) # hide\ncam3d.eyeposition[] = Vec3f(96.91587149289712, 85.36944962225634, -85.12319118529459)  # hide\ncam3d.lookat[] = Vec3f(95.90360332812566, 85.36944962225634, 2.943478780350152)  # hide\ncam3d.upvector[] = Vec3f(0.9999339466437674, 0.0, 0.01149357861675617)  # hide\nMakie.zoom!(sc.scene, cam3d, 0.10f0)  # hide\nf","category":"page"},{"location":"plot/#Plotting-the-streamlines","page":"Plotting","title":"Plotting the streamlines","text":"","category":"section"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"We rely on the function plot_streamlines! provides the information regarding the keyword arguments.","category":"page"},{"location":"plot/","page":"Plotting","title":"Plotting","text":"# make some streamlines\nstreamlines = zeros(Float32, 6, 100, 20)\nfor n = 1:20\n    v0 = rand(3)*15\n    for nt = 1:100\n        streamlines[1:3, nt, n] .= v0 + nt .* [1,1+0.1*rand(),0]\n    end\nend\n# plot the streamlines and the glyph\nf = Figure(backgroundcolor = :white)\nlscene = LScene(f[1,1])\nTG.plot_streamlines!(lscene.scene, streamlines[1:3, 1:1:end, :])\nTG.plot_odf!(lscene, model; n_sphere = 1500, radius = 1.3, st = 4);\nf","category":"page"},{"location":"gpu/#GPU-example","page":"GPU example","title":"GPU example","text":"","category":"section"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"Here is an example which works on GPU. The implementation is agnostic to the GPU vendor but we focus on NVIDIA for this example.","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"To speed up computations, we restrict to Float32, this is handled easily by the package.","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"danger: Danger\nBecause allocations matter a lot on GPU, we pre-allocate all the memory required for computations and fill this inplace.","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"using Tractography\nconst TG = Tractography\n\n# define the model for TMC\nmodel = TMC(Œît = 0.125f0,\n            odfdata = ODFData((@__DIR__) * \"/../../examples/fod-FC.nii.gz\"),\n            cone = Cone(45f0),\n            proba_min = 0.005f0,\n            )","category":"page"},{"location":"gpu/#Define-the-seeds","page":"GPU example","title":"Define the seeds","text":"","category":"section"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"using CUDA\n# number of streamlines\nNmc = 1024*400\n# maximum number of steps for each streamline\nNt = 2000\n# define the seeds\nseeds = cu(zeros(6, Nmc));\nseeds[1:3, :] .= [-13.75, 26.5, 8] .+ 0.1  .* randn(3, Nmc) .|> Float32 |> CuArray;\nseeds[4, :] .= 1\ntract_length = CuArray((zeros(UInt32, Nmc))","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"we next define a buffer to hold the streamlines","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"streamlines_gpu = cu(zeros(Float32, 3, Nt, Nmc), unified = true)","category":"page"},{"location":"gpu/#Define-the-computation-cache","page":"GPU example","title":"Define the computation cache","text":"","category":"section"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"Because we can compute the streamlines in batches for the same TMC, it is best to cache some data for this","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"# we precompute the cache which is heavy otherwise each call to sample\n# will recompute it\ncache_g = TG.init(model, Probabilistic(); \n                  ùíØ‚Çê = CuArray,\n                  n_sphere = 400);","category":"page"},{"location":"gpu/#Compute-the-streamlines","page":"GPU example","title":"Compute the streamlines","text":"","category":"section"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"The following takes 0.5s on a A100.","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"# this setup works for a GPU with 40GiB\n# it yields 1e6/sec streamlines for Probabilistic\n# and 2.2e6/sec streamlines for Deterministic\nCUDA.@time TG.sample!(\n            streamlines_gpu,\n            tract_length,\n            model,\n            cache_g,\n            Probabilistic(),\n            # Deterministic(),\n            seeds;\n            # maxodf_start = true,\n            # reverse_direction = true,\n            gputhreads = 1024,\n            );","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"tip: batches\nThis can be called many times, for example after updating the seeds.","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"So far the streamlines streamlines_gpu are on the GPU. We can retrieve them at zero cost on the CPU","category":"page"},{"location":"gpu/","page":"GPU example","title":"GPU example","text":"streamlines = @time unsafe_wrap(Array, streamlines_gpu);","category":"page"},{"location":"#Tractography.jl","page":"Home","title":"Tractography.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package aims at tractography by taking advantage of parallel and specific hardwares (e.g. GPU). Tractography aims at reconstructing white matter fiber bundles using diffusion-weighted MRI. It thus aim to study the structural connectivity of the brain.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Installation","page":"Home","title":"üì¶ Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Assuming that you already have Julia correctly installed, it suffices to import Tractography.jl in the standard way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"Tractography\")","category":"page"},{"location":"#Citing-this-work","page":"Home","title":"üìö Citing this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To come...","category":"page"},{"location":"#Other-softwares","page":"Home","title":"üßë‚Äçüíª Other softwares","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are several good softwares already available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DIPY\nDSI-studio\nEntrack\nExploreDTI\nFibers.jl julia set of tools to deal with diffusion MRI data.\nMRtrix the main software to perform, among other things, tractography. It lacks GPU capability though.\nMicrostructure.jl\nScilpy\nTrekker","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia, the present package seems to be the only one focused on tractography.","category":"page"},{"location":"#A-word-on-performance","page":"Home","title":"A word on performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The examples which follow have not all been written with the goal of performance but rather simplicity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, note that this code was used to sample 500 000 000 000 streamlines on GPU for a recent publication.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Yanis Aeschlimann, Samuel Deslauriers-Gauthier, Romain Veltz. GPU tractography: What can we learn from half a trillion streamlines? International Society for Tractography Conference - IST 2025, Oct 2025, Bordeaux (France), France. ‚ü®hal-05272265‚ü©","category":"page"}]
}
